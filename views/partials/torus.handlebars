<canvas id="c"></canvas>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.164.0/build/three.module",
      "three/addons/": "https://unpkg.com/three@0.164.0/examples/jsm/"
    }
  }
</script>
<script type="module">

			import * as THREE from 'three';

			import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
            	import {RGBELoader} from "https://cdn.jsdelivr.net/npm/three@0.124/examples/jsm/loaders/RGBELoader.js"


			let camera, scene, renderer;
		    const canvas = document.querySelector( '#c' );

			const api = {

				count: 2000,
				distribution: 'random',
				resample: resample,
				surfaceColor: 0xFFF784,
				backgroundColor: 0xE39469,

			};

			let stemMesh, blossomMesh;
			let stemGeometry, blossomGeometry;
			let stemMaterial, blossomMaterial;

			let sampler;
			const count = api.count;
			const ages = new Float32Array( count );
			const scales = new Float32Array( count );
			const dummy = new THREE.Object3D();

			const _position = new THREE.Vector3();
			const _normal = new THREE.Vector3();
			const _scale = new THREE.Vector3();

			// let surfaceGeometry = new THREE.BoxGeometry( 10, 10, 10 ).toNonIndexed();
			// const surfaceGeometry = new THREE.TorusKnotGeometry( 10, 3, 100, 16 ).toNonIndexed();
			// const surfaceMaterial = new THREE.MeshLambertMaterial( { color: api.surfaceColor, wireframe: false } );
			//const surface = new THREE.Mesh( surfaceGeometry, surfaceMaterial );

         
			let surface;
            let model;

            const hdrEquirect = new RGBELoader().load(
			"glb/env.hdr",
				() => {
					hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;
				}
			);

            const material = new THREE.MeshPhysicalMaterial({
                color: 'rgb(0, 255, 47)',    // red (can also use a CSS color string here)
                transmission: 0.3,
                thickness: 3,
                roughness: 1,
            

            });
            const transparentmaterial = new THREE.MeshPhysicalMaterial({
                transmission: 0.9,      
                roughness: 1,
                color: 'rgb(0, 255, 47)',
        
            });

			// Source: https://gist.github.com/gre/1650294
			const easeOutCubic = function ( t ) {

				return ( -- t ) * t * t + 1;

			};

			// Scaling curve causes particles to grow quickly, ease gradually into full scale, then
			// disappear quickly. More of the particle's lifetime is spent around full scale.
			const scaleCurve = function ( t ) {

				return Math.abs( easeOutCubic( ( t > 0.5 ? 1 - t : t ) * 2 ) );

			};

			const loader = new GLTFLoader();

			loader.load( 'glb/pill.glb', function ( gltf ) {


		        model = gltf.scene;		
				model.children[0].material = material;
				model.children[1].material = transparentmaterial;
			    model.scale.set(1,1,1);
				
                surface = new THREE.Mesh( new THREE.CapsuleGeometry( 1, 3, 4, 8 ), transparentmaterial );
				const _stemMesh = new THREE.SphereGeometry( 0.01 )

				stemGeometry = _stemMesh.clone();

				const defaultTransform = new THREE.Matrix4()
					.makeRotationX( Math.PI )
					.multiply( new THREE.Matrix4().makeScale( 7, 7, 7 ) );

				stemGeometry.applyMatrix4( defaultTransform );
				stemMaterial = material;

				stemMesh = new THREE.InstancedMesh( stemGeometry, stemMaterial, count );

				// Instance matrices will be updated every frame.
				stemMesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage );

				resample();

				init();

			} );

			function init() {



                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
		        camera.position.z =10;
                camera.lookAt( 0, 0, 0 );

				//

				scene = new THREE.Scene();
			    scene.environment =hdrEquirect;

				const pointLight = new THREE.PointLight( 0xAA8899, 2.5, 0, 0 );
				pointLight.position.set( 50, - 25, 75 );
				scene.add( pointLight );

				scene.add( new THREE.AmbientLight( 0xffffff, 3 ) );

				//
	            scene.add( surface );
				scene.add( stemMesh );

			//

				const gui = new GUI();
				gui.add( api, 'count', 0, count ).onChange( function () {

					stemMesh.count = api.count;
			

				} );

	
				gui.add( api, 'distribution' ).options( [ 'random', 'weighted' ] ).onChange( resample );
				gui.add( api, 'resample' );

				//

				
			    renderer = new THREE.WebGLRenderer( { antialias: true,  alpha: true, canvas } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );

				//


				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function resample() {

				const vertexCount = surface.geometry.getAttribute( 'position' ).count;

				console.info( 'Sampling ' + count + ' points from a surface with ' + vertexCount + ' vertices...' );

				//

				console.time( '.build()' );

				sampler = new MeshSurfaceSampler( surface )
					.setWeightAttribute( api.distribution === 'weighted' ? 'uv' : null )
					.build();

				console.timeEnd( '.build()' );

				//

				console.time( '.sample()' );

				for ( let i = 0; i < count; i ++ ) {

					ages[ i ] = Math.random();
					scales[ i ] = scaleCurve( ages[ i ] );

					resampleParticle( i );

				}

				console.timeEnd( '.sample()' );

				stemMesh.instanceMatrix.needsUpdate = true;

			}

			function resampleParticle( i ) {

				sampler.sample( _position, _normal );
				_normal.add( _position );

				dummy.position.copy( _position );
				dummy.scale.set( scales[ i ], scales[ i ], scales[ i ] );
				dummy.lookAt( _normal );
				dummy.updateMatrix();

				stemMesh.setMatrixAt( i, dummy.matrix );

			}

			function updateParticle( i ) {

				// Update lifecycle.

				ages[ i ] += 0.005;

				if ( ages[ i ] >= 1 ) {

					ages[ i ] = 0.001;
					scales[ i ] = scaleCurve( ages[ i ] );

					resampleParticle( i );

					return;

				}

				// Update scale.

				const prevScale = scales[ i ];
				scales[ i ] = scaleCurve( ages[ i ] );
				_scale.set( scales[ i ] / prevScale, scales[ i ] / prevScale, scales[ i ] / prevScale );

				// Update transform.

				stemMesh.getMatrixAt( i, dummy.matrix );
				dummy.matrix.scale( _scale );
				stemMesh.setMatrixAt( i, dummy.matrix );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {
				render();
			}

			function render() {

				if ( stemMesh  ) {

					const time = Date.now() * 0.001;

					// scene.rotation.x = Math.sin( time / 4 );
					scene.rotation.y = Math.sin( time / 10 );
               
                    scene.rotation.z = Math.sin( time / 10 );

					for ( let i = 0; i < api.count; i ++ ) {
						updateParticle( i );
					}

					stemMesh.instanceMatrix.needsUpdate = true;

					stemMesh.computeBoundingSphere();

				}

				renderer.render( scene, camera );

			}

		</script>
